# PII Agent - 발표용 코드 설명서

## 📋 목차
1. [시스템 개요](#시스템-개요)
2. [핵심 코드 설명](#핵심-코드-설명)
3. [질문 예상 답변](#질문-예상-답변)
4. [데모 시나리오](#데모-시나리오)

---

## 시스템 개요

### 전체 아키텍처
```
사용자 (ChatGPT/Gemini)
    ↓ 파일 업로드/텍스트 입력
Chrome Extension (content.js)
    ↓ 파일 감지 및 Base64 인코딩
Service Worker (background.js)
    ↓ Native Host 호출 (네트워크 정보)
    ↓ 서버로 전송
Python Server (LocalServer.py)
    ↓ 개인정보 탐지 (Logic.py)
    ↓ 결과 저장
Dashboard (실시간 모니터링)
```

### 3가지 핵심 컴포넌트
1. **Chrome Extension**: 파일/텍스트 감지 및 전송
2. **Python Server**: 개인정보 탐지 엔진
3. **Native Host**: 네트워크 정보 수집

---

## 핵심 코드 설명

### 1. 파일 감지 (content.js) ⭐ 발표 핵심

#### 1-1. 3가지 파일 업로드 방식 감지
```javascript
// ① input[type=file] 감지
document.addEventListener("change", (e) => {
    if(e.target.tagName === "INPUT" && e.target.type === "file") {
        // 파일 선택 시 대기 목록에 추가
        for(const f of input.files) {
            storeFileForLater(f, location.href);
        }
    }
}, true);

// ② 드래그 앤 드롭 감지
document.addEventListener("drop", async (e) => {
    if (e.dataTransfer?.files?.length) {
        for(const f of e.dataTransfer.files) {
            await storeFileForLater(f, location.href);
        }
    }
}, true);

// ③ 클립보드 붙여넣기 감지
document.addEventListener("paste", async (e) => {
    if (e.clipboardData?.files?.length) {
        for(const f of e.clipboardData.files) {
            await storeFileForLater(f, location.href);
        }
    }
}, true);
```

**발표 포인트:**
- 사용자가 어떤 방식으로 파일을 업로드하든 모두 감지
- 대기 목록에 저장 후 전송 버튼 클릭 시 일괄 전송

#### 1-2. 전송 버튼 감지 (중요!)
```javascript
// Enter 키 전송
document.addEventListener("keydown", async (e) => {
    if (e.key === "Enter" && !e.shiftKey) {
        // 텍스트 + 파일 통합 전송
        await sendViaPort("COMBINED_EVENT", {
            raw_text: text,
            files_data: pendingFiles,
            source_url: location.href
        });
    }
}, true);

// 클릭 전송 (ChatGPT/Gemini 전송 버튼)
document.addEventListener("click", async (e) => {
    // 전송 버튼 감지 로직
    if (isSendButton && (pendingFiles.length > 0 || lastCapturedText)) {
        await sendViaPort("COMBINED_EVENT", {...});
    }
}, true);
```

**발표 포인트:**
- Enter 키와 클릭 모두 지원
- 텍스트와 파일을 함께 전송 (통합 처리)

#### 1-3. 취소 버튼 감지 (오탐지 방지)
```javascript
// 취소 버튼 클릭 시 대기 파일 삭제
document.addEventListener("click", (e) => {
    const ariaLabel = el.getAttribute("aria-label");
    if (ariaLabel.includes("제거") || ariaLabel.includes("close")) {
        pendingFiles.length = 0;  // 대기 파일 삭제
        filesMap.clear();
    }
}, true);
```

**발표 포인트:**
- 사용자가 파일 업로드를 취소하면 대기 목록에서 삭제
- 불필요한 전송 방지

---

### 2. 개인정보 탐지 (Logic.py) ⭐ 발표 핵심

#### 2-1. 3단계 탐지 시스템
```python
# 1단계: 정규식 탐지 (전화번호, 이메일, 주민번호 등)
regex_results = detect_by_regex(combined_text)

# 2단계: NER 모델 탐지 (이름, 조직명, 주소)
ner_results = detect_by_ner(combined_text)

# 3단계: 준식별자 탐지 (직책)
quasi_results = detect_quasi_identifiers(combined_text)
```

**발표 포인트:**
- 정규식: 패턴 기반 (빠르고 정확)
- NER: AI 모델 기반 (문맥 이해)
- 준식별자: 조합 위험도 분석용

#### 2-2. 조합 위험도 분석 ⭐⭐ 핵심 차별점
```python
def analyze_combination_risk(detected_items, text):
    # 카테고리별 분류
    identifier_count = len([...])  # 이름, 주민번호, 전화번호 등
    quasi_count = len([...])       # 조직명, 주소, 직책
    sensitive_count = len([...])   # 얼굴사진
    
    # 치명적: 민감정보 + 식별자
    if sensitive_count > 0 and identifier_count > 0:
        risk_level = 'critical'
        risk_message = '민감정보 + 식별자 조합 → 개인 완전 특정 가능!'
    
    # 고위험: 식별자 3개 이상
    elif identifier_count >= 3:
        risk_level = 'high'
        risk_message = f'식별자 {identifier_count}개 → 개인 특정 가능'
    
    # 중위험: 식별자 2개
    elif identifier_count >= 2:
        risk_level = 'medium'
        risk_message = f'식별자 {identifier_count}개 → 개인 특정 가능성 있음'
```

**발표 포인트:**
- 단순히 개인정보를 찾는 게 아니라 **조합 위험도**를 분석
- 예: "홍길동"만 있으면 탐지 안 함 (흔한 이름)
- 예: "홍길동 + 삼성전자 + 부장" → 고위험 (개인 특정 가능)

#### 2-3. 개인정보 분류 체계
```python
def categorize_detection(item):
    # 식별자 (개인을 직접 특정 가능)
    if item_type in ['PS', 'PER', 'ssn', 'phone', 'email', ...]:
        return 'identifier'
    
    # 민감정보 (얼굴사진)
    if item_type in ['image_face']:
        return 'sensitive'
    
    # 준식별자 (조합시 특정 가능)
    if item_type in ['ORG', 'OG', 'LC', 'position']:
        return 'quasi'
```

**발표 포인트:**
- 개인정보보호법 기준에 맞춘 분류
- 조합 위험도 없으면 준식별자는 결과에서 제외

#### 2-4. 검증 로직 (오탐지 방지)
```python
# 주민번호 검증
def validate_ssn(ssn: str) -> bool:
    # 1. 생년월일 유효성 검사
    datetime.date(full_year, mm, dd)
    
    # 2. 체크섬 검증
    weights = [2, 3, 4, 5, 6, 7, 8, 9, 2, 3, 4, 5]
    s = sum(int(ssn[i]) * weights[i] for i in range(12))
    check = (11 - (s % 11)) % 10
    return check == int(ssn[-1])

# 카드번호 검증 (Luhn 알고리즘)
def validate_luhn(card_number: str) -> bool:
    # Luhn 체크섬 검증
    return checksum % 10 == 0

# 운전면허 검증
def validate_driver_license(license_num: str) -> bool:
    # 지역코드 검증 (11~26, 24 제외)
    valid_region_codes = {'11', '12', '13', ...}
    return region_code in valid_region_codes
```

**발표 포인트:**
- 단순 패턴 매칭이 아닌 **실제 검증**
- 유효하지 않은 번호는 탐지 제외 (오탐지 방지)

---

### 3. 파일 파싱 (Logic.py)

#### 3-1. 지원 파일 형식 (구버전 자동 변환)
```python
def parse_file(File_Bytes: bytes, File_Ext: str):
    if File_Ext == "txt":
        return File_Bytes.decode("utf-8"), False
    
    elif File_Ext == "doc":  # 구버전 자동 변환
        # pywin32로 Word 실행 → DOCX 변환
        word = win32com.client.Dispatch("Word.Application")
        doc.SaveAs(tmp_docx_path, FileFormat=16)
        return parse_file(converted, "docx")
    
    elif File_Ext == "docx":
        doc = Document(io.BytesIO(File_Bytes))
        # 단락 + 테이블 텍스트 추출
        
    elif File_Ext == "xls":  # 구버전 자동 변환
        # pywin32로 Excel 실행 → XLSX 변환
        excel = win32com.client.Dispatch("Excel.Application")
        wb.SaveAs(tmp_xlsx_path, FileFormat=51)
        return parse_file(converted, "xlsx")
```

**발표 포인트:**
- 14가지 파일 형식 지원
- 구버전 파일 자동 변환 (DOC→DOCX, XLS→XLSX)
- HWP 특수 처리 (띄어쓰기 문제 해결)
- PPT는 미지원 (PPTX로 변환 후 업로드)

#### 3-2. HWP 띄어쓰기 정규화 ⭐ 차별점
```python
# HWP는 "이 무 송" 형태로 저장
# 자동 정규화: "이 무 송" → "이무송"
while True:
    prev = text
    text = re.sub(r'([가-힣])\s+([가-힣])(?=\s|[가-힣]|$)', r'\1\2', text)
    if prev == text:
        break
```

**발표 포인트:**
- HWP 파일의 고질적인 문제 해결
- 반복 적용으로 완전한 정규화

#### 3-3. 얼굴 탐지 (MTCNN)
```python
def detect_faces_in_image_bytes(image_bytes, confidence_threshold=0.98):
    # 1. 신뢰도 98% 이상만
    if conf < confidence_threshold:
        continue
    
    # 2. 얼굴 크기 검증
    if w < 30 or h < 30:
        continue
    
    # 3. 가로세로 비율 검증
    aspect_ratio = w / h
    if aspect_ratio < 0.6 or aspect_ratio > 1.5:
        continue
    
    # 4. keypoints 검증 (눈, 코, 입)
    if not (left_eye and right_eye and nose):
        continue
```

**발표 포인트:**
- 4단계 필터링으로 오탐지 방지
- 로고, 아이콘 등 제외

---

### 4. 서버 (LocalServer.py)

#### 4-1. 통합 API 엔드포인트
```python
@app.post("/api/combined")
async def handle_combined(request: Request):
    # 텍스트 + 파일 통합 처리
    text = data.get("text", "")
    files_data = data.get("files_data", [])
    
    # 텍스트 탐지
    if text.strip():
        detected = detect_text(text)
    
    # 파일 탐지
    for file_info in files_data:
        detected = detect_file(file_info)
```

**발표 포인트:**
- 하나의 API로 텍스트 + 파일 동시 처리
- 효율적인 통합 처리

#### 4-2. 실시간 대시보드
```python
@app.get("/dashboard")
async def dashboard():
    # 실시간 탐지 내역 표시
    # 3초마다 자동 갱신
```

**발표 포인트:**
- 실시간 모니터링 가능
- 네트워크 정보 (IP, 호스트명, 브라우저) 표시

---

## 질문 예상 답변

### Q1. "왜 Chrome Extension을 사용했나요?"
**A:** ChatGPT/Gemini는 웹 기반 서비스이므로, 사용자가 입력하는 데이터를 실시간으로 감지하려면 브라우저 확장 프로그램이 필요합니다. Extension은 웹 페이지의 DOM에 접근하여 파일 업로드, 텍스트 입력을 감지할 수 있습니다.

### Q2. "NER 모델은 어떤 걸 사용했나요?"
**A:** `soddokayo/klue-roberta-base-ner` 모델을 사용했습니다. 한국어 특화 모델로, 이름(PS), 조직명(ORG), 주소(LC) 등을 탐지합니다. 오탐지 방지를 위해 신뢰도 기반 필터링을 적용합니다:
- 2글자 이름: 신뢰도 90% 이상만
- 3글자 이름: 제한 없음
- 4글자 이상: 신뢰도 80% 이상만

### Q3. "조합 위험도 분석이 뭔가요?" ⭐ 핵심 질문
**A:** 개인정보의 개수와 조합에 따라 위험도를 자동 계산합니다.

**위험도 규칙:**
- **치명적 (CRITICAL)**: 민감정보(얼굴사진) + 식별자(이름 등) → 개인 완전 특정!
- **고위험 (HIGH)**: 식별자 3개 이상 (이름+전화번호+이메일) → 개인 특정 가능
- **중위험 (MEDIUM)**: 식별자 2개 (이름+전화번호) → 개인 특정 가능성

**예시:**
- "홍길동" 단독 → 탐지 안 됨 (1개)
- "홍길동 + 010-1234-5678" → 중위험 (2개)
- "홍길동 + 010-1234-5678 + hong@example.com" → 고위험 (3개)
- "증명사진 + 홍길동" → 치명적 (민감정보+식별자)

### Q4. "HWP 파일은 어떻게 처리하나요?"
**A:** HWP는 텍스트를 "이 무 송" 형태로 저장하는 문제가 있습니다. 이를 해결하기 위해:
1. 한글 띄어쓰기 정규화 ("이 무 송" → "이무송")
2. 정규식 이름 추출 ("성명이무송" 패턴)
3. 주소 자동 병합 ("##서울특별시" + "##강남구" → "서울특별시 강남구")

### Q5. "오탐지는 어떻게 방지하나요?"
**A:** 4가지 방법으로 오탐지를 방지합니다:
1. **검증 로직**: 주민번호 체크섬, 카드번호 Luhn 알고리즘, 운전면허 지역코드 검증
2. **신뢰도 필터링**: NER 모델 신뢰도 기반 (2글자=90%, 4글자+=80%)
3. **패턴 필터링**: 한글 없음, 숫자만 있음, 조직명 키워드 체크
4. **조합 분석**: 식별자 2개 미만은 표시 안 함

### Q6. "얼굴 탐지는 어떻게 하나요?"
**A:** MTCNN 모델을 사용하며, 4단계 필터링으로 오탐지를 방지합니다:
1. 신뢰도 98% 이상만
2. 얼굴 크기 검증 (30px 이상)
3. 가로세로 비율 검증 (0.6~1.5)
4. keypoints 검증 (눈, 코, 입 위치)

### Q7. "성능은 어떤가요?"
**A:** 
- **텍스트**: 1000글자 기준 0.5초 이내
- **파일**: PDF 10페이지 기준 2~3초
- **병렬 처리**: PDF 얼굴 탐지는 8 workers로 병렬 처리 (2~4배 빠름)
- **메모리**: deque로 최대 1000개만 유지 (메모리 누수 방지)

### Q8. "보안은 어떻게 되나요?"
**A:** 
1. **CORS 화이트리스트**: Extension ID 기반 접근 제어
2. **HMAC 인증**: 선택적 API 인증 (환경변수로 활성화)
3. **타임스탬프 검증**: 5분 이내 요청만 허용
4. **파일 크기 제한**: 100MB 하드 리미트

### Q9. "왜 Native Host를 사용했나요?"
**A:** Chrome Extension은 보안상 네트워크 정보(IP, 호스트명)에 직접 접근할 수 없습니다. Native Host는 Python 프로세스로, 시스템 정보를 수집하여 Extension에 전달합니다.

### Q10. "실제 사용 시나리오는?"
**A:** 
1. 기업 내부: 직원이 ChatGPT에 민감정보를 업로드하는 것을 실시간 모니터링
2. 교육 기관: 학생들이 과제 제출 시 개인정보 포함 여부 확인
3. 개인: 자신의 문서에 개인정보가 있는지 자가 점검

---

## 데모 시나리오

### 시나리오 1: 텍스트 입력 (기본)
1. ChatGPT 접속
2. "홍길동 010-1234-5678" 입력
3. Enter 키 전송
4. 대시보드에서 실시간 탐지 확인
   - 이름: 홍길동
   - 전화번호: 010-1234-5678
   - 조합 위험도: 고위험 (이름+전화번호)

### 시나리오 2: 파일 업로드 (DOCX)
1. 이력서.docx 파일 드래그 앤 드롭
2. 전송 버튼 클릭
3. 대시보드 확인
   - 파일명: (이름)_(전화번호)_이력서.docx (마스킹됨)
   - 탐지 항목: 이름, 전화번호, 이메일, 주소 등

### 시나리오 3: 조합 위험도 (차별점 강조)
1. "홍길동" 입력 → 탐지 안 됨 (식별자 1개)
2. "홍길동 010-1234-5678" 입력 → 중위험 (식별자 2개)
3. "홍길동 010-1234-5678 hong@example.com" 입력 → 고위험 (식별자 3개)

### 시나리오 4: HWP 파일 (차별점 강조)
1. HWP 파일 업로드 (띄어쓰기 문제 있는 파일)
2. 자동 정규화 후 탐지 성공
3. 콘솔 로그 확인:
   ```
   [INFO] ⚠ HWP 한글 띄어쓰기 정규화 적용
   [DEBUG] 원본: 이 무 송
   [DEBUG] 정규화: 이무송
   ```

### 시나리오 5: 얼굴 탐지
1. 증명사진이 포함된 이력서 PDF 업로드
2. 얼굴 탐지 결과 확인
3. 대시보드에서 "image_face" 타입 확인

---

## 발표 시 강조할 핵심 포인트

### 1. 차별화 요소 ⭐⭐⭐
1. **조합 위험도 분석**: 단순 탐지가 아닌 지능형 분석
2. **HWP 띄어쓰기 정규화**: 한국 특화 기능
3. **3가지 파일 업로드 방식 모두 지원**: 드롭, 붙여넣기, 선택
4. **실시간 모니터링**: 대시보드로 즉시 확인

### 2. 기술적 완성도
1. **검증 로직**: 주민번호, 카드번호, 운전면허 검증
2. **오탐지 방지**: 4단계 필터링 (얼굴 탐지)
3. **병렬 처리**: 성능 최적화 (2~4배 향상)
4. **보안**: CORS, HMAC 인증, 파일 크기 제한

### 3. 실용성
1. **14가지 파일 형식 지원**
2. **실시간 대시보드**
3. **네트워크 정보 수집** (IP, 호스트명, 브라우저)
4. **파일명 자동 마스킹**

---

## 발표 순서 추천

1. **문제 정의** (1분)
   - ChatGPT/Gemini 사용 시 개인정보 유출 위험

2. **시스템 개요** (2분)
   - 전체 아키텍처 설명
   - 3가지 핵심 컴포넌트

3. **핵심 기능 시연** (5분)
   - 시나리오 1: 텍스트 입력
   - 시나리오 3: 조합 위험도 (차별점 강조)
   - 시나리오 4: HWP 파일 (차별점 강조)

4. **기술적 설명** (3분)
   - 파일 감지 방식
   - 개인정보 탐지 로직
   - 조합 위험도 분석

5. **질의응답** (4분)
   - 예상 질문 답변 준비

---

## 추가 팁

### 발표 전 체크리스트
- [ ] 서버 실행 확인 (http://127.0.0.1:9000)
- [ ] Extension 설치 확인
- [ ] 대시보드 접속 확인
- [ ] 테스트 파일 준비 (DOCX, PDF, HWP)
- [ ] 네트워크 연결 확인

### 데모 실패 시 대응
1. **서버 연결 실패**: 미리 녹화한 영상 준비
2. **파일 업로드 실패**: 텍스트 입력으로 대체
3. **탐지 실패**: 콘솔 로그로 설명

### 강조할 숫자
- **14가지** 파일 형식 지원
- **98%** 얼굴 탐지 신뢰도
- **2~4배** 성능 향상 (병렬 처리)
- **100MB** 파일 크기 제한
- **3초** 실시간 대시보드 갱신
