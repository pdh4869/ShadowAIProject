================================================================================
Logic_Final.py 코드 비교 (변경 전 vs 변경 후)
================================================================================

📅 작성일: 2024년
📝 목적: 실제 코드 레벨에서 변경 전후 비교

================================================================================
1. 전화번호 탐지 - detect_by_regex() 함수
================================================================================

[변경 전 - 제공된 코드]
────────────────────────────────────────────────────────────────────────────
def detect_by_regex(Text: str) -> list:
    normalized_text = re.sub(r'[\s\-]', '', Text)
    detected = []
    for label, pattern in COMPILED_PATTERNS.items():
        for match in pattern.finditer(Text):
            item = {"type": label, "value": match.group(), "span": match.span()}
            if label == "card":
                item["status"] = "valid" if validate_luhn(item["value"]) else "invalid (Luhn)"
            if label == "ssn":
                item["status"] = "valid" if validate_ssn(item["value"]) else "invalid (SSN)"
            detected.append(item)
────────────────────────────────────────────────────────────────────────────

[변경 후 - 현재 버전]
────────────────────────────────────────────────────────────────────────────
def detect_by_regex(Text: str) -> list:
    normalized_text = re.sub(r'[\s\-]', '', Text)
    detected = []
    seen_values = set()  # 중복 방지
    for label, pattern in COMPILED_PATTERNS.items():
        for match in pattern.finditer(Text):
            # 전화번호 검증
            if label == "phone":
                start, end = match.span()
                matched_text = match.group()
                phone_digits = re.sub(r'\D', '', matched_text)
                
                # 전화번호 길이 검증 (9~11자리)
                if len(phone_digits) < 9 or len(phone_digits) > 11:
                    continue
                
                # 유효한 전화번호 형식인지 먼저 검증
                valid_prefixes = ['010', '02', '031', '032', '033', '041', '042', '043', '044', 
                                  '051', '052', '053', '054', '055', '061', '062', '063', '064', '070']
                if not any(phone_digits.startswith(prefix) for prefix in valid_prefixes):
                    continue
                
                # 앞뒤 좁은 컨텍스트 확인
                context_start = max(0, start - 10)
                context_end = min(len(Text), end + 10)
                context = Text[context_start:context_end]
                
                # 날짜 패턴이 바로 인접해 있으면 제외
                if re.search(r'(19|20)\d{2}[년월일\-/\.]', context):
                    continue
                
                # 앞뒤에 영문자가 붙어있으면 제외
                if (start > 0 and Text[start-1].isalpha()) or (end < len(Text) and Text[end].isalpha()):
                    continue
                
                # 연속된 숫자 체크
                if len(phone_digits) > 1:
                    is_sequential = all(int(phone_digits[i]) == (int(phone_digits[i-1]) + 1) % 10 for i in range(1, len(phone_digits)))
                    if is_sequential:
                        continue
            
            # 생년월일 검증: 키워드 기반 필터링
            if label == "birth":
                start, end = match.span()
                # 앞뒤 50글자 범위에서 키워드 찾기
                context_start = max(0, start - 50)
                context_end = min(len(Text), end + 50)
                context = Text[context_start:context_end].lower()
                
                # 생년월일 관련 키워드
                birth_keywords = ['생년월일', '생일', '출생', '생년', 'birth', 'dob', 'date of birth']
                # 제외 키워드 (입사일 등)
                exclude_keywords = ['입사', '퇴사', '계약', '신고', '등록', '수정', '발급', '승인', '승인일', '가입', '신청', 'join', 'hire', 'contract', 'register']
                
                has_birth_keyword = any(kw in context for kw in birth_keywords)
                has_exclude_keyword = any(kw in context for kw in exclude_keywords)
                
                # 생년월일 키워드가 있고 제외 키워드가 없을 때만 탐지
                if not has_birth_keyword or has_exclude_keyword:
                    continue
            
            matched_value = match.group()
            # 중복 체크
            value_key = f"{label}:{matched_value}"
            if value_key in seen_values:
                continue
            seen_values.add(value_key)
            
            item = {"type": label, "value": matched_value, "span": match.span()}
            if label == "card":
                item["status"] = "valid" if validate_luhn(item["value"]) else "invalid (Luhn)"
            if label == "ssn":
                item["status"] = "valid" if validate_ssn(item["value"]) else "invalid (SSN)"
            detected.append(item)
────────────────────────────────────────────────────────────────────────────

================================================================================
2. 이름 탐지 - detect_by_ner() 함수 (PS/PER 블록)
================================================================================

[변경 전 - 제공된 코드]
────────────────────────────────────────────────────────────────────────────
if Label in ['PS', 'PER']:
    clean_word = Word.replace(" ", "").strip()
    
    if clean_word in NAME_BLACKLIST:
        continue
    
    if len(clean_word) <= 1 or clean_word.isdigit() or not any('\uac00' <= c <= '\ud7a3' for c in clean_word):
        continue
    
    org_keywords = ['회사', '전자', '그룹', '은행', '병원', '학교', '팀', '부']
    if any(kw in clean_word for kw in org_keywords):
        continue

    if len(clean_word) == 2 and score < 0.90:
        continue
    if len(clean_word) >= 4 and score < 0.80:
        continue
────────────────────────────────────────────────────────────────────────────

[변경 후 - 현재 버전]
────────────────────────────────────────────────────────────────────────────
if Label in ['PS', 'PER']:
    clean_word = Word.replace(" ", "").strip()
    if len(clean_word) <= 1 or clean_word.isdigit() or not any('\uac00' <= c <= '\ud7a3' for c in clean_word):
        continue
    
    # 숫자 포함 제외
    if any(c.isdigit() for c in clean_word):
        continue
    
    # 제외 단어 필터 (정규식과 동일)
    if clean_word in exclude_words:
        continue
    
    # 직위 키워드 제외
    position_keywords = ['사원', '대리', '과장', '차장', '부장', '이사', '상무', '전무', '부사장', '사장', '주임', '선임', '책임', '수석', '부수석', '원장', '부원장', '국장', '부국장', '실장', '팀장']
    if clean_word in position_keywords:
        continue
    
    org_keywords = ['회사', '전자', '그룹', '기업', '주식회사', '(주)', '㉼', '학교', '대학교', '대학', '고등학교', '중학교', '초등학교', '병원', '의원', '센터', '연구소', '재단', '협회', '은행', '부서', '팀', '본부', '지점', '영업소', '축산', '농장', '목장', '마트', '플러스', '점포', '상회']
    if any(kw in clean_word for kw in org_keywords):
        if clean_word not in detected_orgs:
            Detected.append({"type": "ORG", "value": Word, "span": (Start, End)})
            detected_orgs.add(clean_word)
        continue
    
    # 3글자 한글 이름만 허용
    if len(clean_word) != 3:
        continue
    
    # 성씨로 시작하지 않으면 제외
    if clean_word[0] not in KOREAN_SURNAMES:
        continue
    
    # 일반 명사 패턴 제외 (조사 포함)
    if clean_word.endswith(('을', '를', '이', '가', '은', '는', '에', '의', '로', '와', '과')):
        continue
    
    # 중복 방지
    if clean_word in detected_names:
        continue
    
    # 필터 통과한 이름만 추가
    Detected.append({"type": Label, "value": Word, "span": (Start, End)})
    detected_names.add(clean_word)
    continue
────────────────────────────────────────────────────────────────────────────

================================================================================
3. NER 512 토큰 제한 해결 - detect_by_ner() 함수
================================================================================

[변경 전 - 제공된 코드]
────────────────────────────────────────────────────────────────────────────
try:
    ner_results = ner_pipeline(Text)
    
    for entity in ner_results:
        Label = entity['entity_group'].upper()
        Word = entity['word'].replace('##', '')
        # ... 처리 로직
────────────────────────────────────────────────────────────────────────────

[변경 후 - 현재 버전]
────────────────────────────────────────────────────────────────────────────
try:
    # NER 모델 512 토큰 제한 해결: 분할 처리
    ner_results = []
    max_length = 500  # 안전 마진
    if len(Text) > max_length:
        chunks = [Text[i:i+max_length] for i in range(0, len(Text), max_length)]
        for chunk in chunks:
            ner_results.extend(ner_pipeline(chunk))
    else:
        ner_results = ner_pipeline(Text)
    
    for entity in ner_results:
        Label = entity['entity_group'].upper()
        Word = entity['word'].replace('##', '')
        # ... 처리 로직
────────────────────────────────────────────────────────────────────────────

================================================================================
4. HWP 파일 처리 - parse_file() 함수
================================================================================

[변경 전 - 제공된 코드]
────────────────────────────────────────────────────────────────────────────
elif File_Ext == "hwp":
    # ... olefile 처리 ...
    
    # [FIX 2] 텍스트 존재 여부와 상관없이 항상 이미지 OCR을 실행
    try:
        ocr_text = run_ocr_on_hwp_images(File_Bytes)
        if ocr_text.strip():
            logging.info(f"[INFO] ✓ HWP(ole) 이미지 OCR 실행: {len(ocr_text)}자 감지")
    except Exception as e:
        logging.warn(f"[WARN] HWP(ole) 이미지 OCR 실행 실패: {e}")

    ole.close()

    # 본문 텍스트와 이미지 OCR 텍스트를 결합
    text = (text.strip() + "\n" + ocr_text.strip()).strip()

    # --- [추가된 기능] Logic (1).py의 HWP 한글 띄어쓰기 정규화 ---
    original_text = text
    while True:
        prev = text
        text = re.sub(r'([가-힣])\s+([가-힣])(?=\s|[가-힣]|$)', r'\1\2', text)
        if prev == text:
            break
    
    if text != original_text:
        logging.info(f"[INFO] ⚠ HWP 한글 띄어쓰기 정규화 적용")
    # --- [추가 완료] ---
    
    return re.sub(r'\s+', ' ', text.strip()), False
────────────────────────────────────────────────────────────────────────────

[변경 후 - 현재 버전]
────────────────────────────────────────────────────────────────────────────
elif File_Ext == "hwp":
    # ... olefile 처리 ...
    
    # 텍스트 유무와 관계없이 항상 OCR 실행 (이미지 내 텍스트 탐지)
    ocr_text = run_ocr_on_hwp_images(File_Bytes)
    if ocr_text:
        print(f"[INFO] HWP 이미지 OCR 추출: {len(ocr_text)}글자")
        text = (text + "\n" + ocr_text).strip()
    ole.close()
    text = re.sub(r'\s+', ' ', text).strip()
    return text, False
────────────────────────────────────────────────────────────────────────────

차이점: 제공된 코드에 HWP 띄어쓰기 정규화 기능 추가됨

================================================================================
5. win32com 절대 경로 처리 - parse_file() 함수
================================================================================

[변경 전 - 현재 버전]
────────────────────────────────────────────────────────────────────────────
# HWP 변환
hwp = win32com.client.Dispatch("HWPFrame.HwpObject")
hwp.RegisterModule("FilePathCheckDLL", "FilePathCheckerModule")
hwp.Open(tmp_path)
hwp.SaveAs(hwpx_path, "HWPX")
hwp.Quit()

# XLS 변환
excel = win32com.client.Dispatch("Excel.Application")
wb = excel.Workbooks.Open(tmp_path)
wb.SaveAs(xlsx_path, FileFormat=51)

# PPT 변환
pp = win32com.client.Dispatch("PowerPoint.Application")
pres = pp.Presentations.Open(tmp_path, WithWindow=False)
pres.SaveAs(pptx_path, FileFormat=24)
────────────────────────────────────────────────────────────────────────────

[변경 후 - 제공된 코드]
────────────────────────────────────────────────────────────────────────────
# HWP 변환
hwp = win32com.client.Dispatch("HWPFrame.HwpObject")
hwp.RegisterModule("FilePathCheckDLL", "FilePathCheckerModule")
# [FIX 1] COM 객체는 절대 경로를 사용해야 HWP 변환 오류(-2147352562)를 방지할 수 있습니다.
hwp.Open(os.path.abspath(tmp_path))
hwp.SaveAs(os.path.abspath(hwpx_path), "HWPX")
hwp.Quit()

# XLS 변환
excel = win32com.client.Dispatch("Excel.Application")
wb = excel.Workbooks.Open(os.path.abspath(tmp_path))  # [FIX 1] 절대경로
wb.SaveAs(os.path.abspath(xlsx_path), FileFormat=51)  # [FIX 1] 절대경로

# PPT 변환
pp = win32com.client.Dispatch("PowerPoint.Application")
pres = pp.Presentations.Open(os.path.abspath(tmp_path), WithWindow=False)  # [FIX 1] 절대경로
pres.SaveAs(os.path.abspath(pptx_path), FileFormat=24)  # [FIX 1] 절대경로
────────────────────────────────────────────────────────────────────────────

차이점: 제공된 코드에 os.path.abspath() 추가로 COM 오류 방지

================================================================================
6. 조합 위험도 분석 - analyze_combination_risk() 함수
================================================================================

[변경 전 - 제공된 코드]
────────────────────────────────────────────────────────────────────────────
def analyze_combination_risk(detected_items, text):
    if len(detected_items) < 2:
        return None

    categorized = {}
    for it in detected_items:
        cat = categorize_detection(it.get('type',''))
        categorized.setdefault(cat, []).append(it)

    identifiers = categorized.get('identifier', [])
    quasis = categorized.get('quasi', [])
    sensitives = categorized.get('sensitive', [])
    id_cnt = len(identifiers)
    q_cnt = len(quasis)
    sen_cnt = len(sensitives)

    # 바로 위험도 계산으로 진행
    if sen_cnt > 0 and id_cnt > 0:
        risk_level = 'critical'
        # ...
────────────────────────────────────────────────────────────────────────────

[변경 후 - 현재 버전]
────────────────────────────────────────────────────────────────────────────
def analyze_combination_risk(detected_items, text):
    if len(detected_items) < 2:
        return None

    categorized = {}
    for it in detected_items:
        cat = categorize_detection(it.get('type',''))
        categorized.setdefault(cat, []).append(it)

    identifiers = categorized.get('identifier', [])
    quasis = categorized.get('quasi', [])
    sensitives = categorized.get('sensitive', [])
    id_cnt = len(identifiers)
    q_cnt = len(quasis)
    sen_cnt = len(sensitives)

    # 준식별자 필터링: 조직명/주소/직책만 있는 경우 제외
    quasi_types = [q.get('type') for q in quasis]
    
    # 조직명만 2개 이상인 경우 제외
    org_only = all(t in ['ORG', 'OG'] for t in quasi_types)
    if org_only and q_cnt >= 2 and id_cnt == 0:
        return None
    
    # 조직명+주소만 있는 경우 제외
    org_lc_only = all(t in ['ORG', 'OG', 'LC', 'LOC'] for t in quasi_types)
    if org_lc_only and q_cnt >= 2 and id_cnt == 0:
        return None
    
    # 조직명+직책, 주소+직책, 조직+주소+직책 조합 제외
    org_pos_lc_only = all(t in ['ORG', 'OG', 'LC', 'LOC', 'position'] for t in quasi_types)
    if org_pos_lc_only and q_cnt >= 2 and id_cnt == 0:
        return None

    # 위험도 계산
    if sen_cnt > 0 and id_cnt > 0:
        risk_level = 'critical'
        # ...
────────────────────────────────────────────────────────────────────────────

차이점: 현재 버전에 준식별자 필터링 로직 추가

================================================================================
7. handle_input_raw() 함수 - 병렬 처리
================================================================================

[변경 전 - 제공된 코드]
────────────────────────────────────────────────────────────────────────────
def handle_input_raw(Input_Data: bytes, Original_Format: str = None, Original_Filename: str = None):
    if not isinstance(Input_Data, bytes):
        raise ValueError("지원하지 않는 입력 형식입니다.")
    print(f"\n[INFO] ========== 파일 처리 시작 (확장자: {Original_Format}) ==========")

    Parsed_Text, is_image_only = parse_file(Input_Data, Original_Format or "")
    image_detections = scan_file_for_face_images(Input_Data, Original_Format or "")
    
    # ... 탐지 로직 ...
────────────────────────────────────────────────────────────────────────────

[변경 후 - 현재 버전]
────────────────────────────────────────────────────────────────────────────
def handle_input_raw(Input_Data: bytes, Original_Format: str = None, Original_Filename: str = None):
    if not isinstance(Input_Data, bytes):
        raise ValueError("지원하지 않는 입력 형식입니다.")
    print(f"\n[INFO] ========== 파일 처리 시작 (확장자: {Original_Format}) ==========")

    # 병렬 처리: 텍스트 추출과 얼굴 탐지를 동시에 실행
    with ThreadPoolExecutor(max_workers=2) as executor:
        text_future = executor.submit(parse_file, Input_Data, Original_Format or "")
        face_future = executor.submit(scan_file_for_face_images, Input_Data, Original_Format or "")
        
        Parsed_Text, is_image_only = text_future.result()
        image_detections = face_future.result()
    
    # ... 탐지 로직 ...
────────────────────────────────────────────────────────────────────────────

차이점: 현재 버전에 병렬 처리 추가로 성능 향상

================================================================================
8. 추가 탐지 함수 - detect_address()
================================================================================

[현재 버전]
────────────────────────────────────────────────────────────────────────────
# 함수 없음 - NER 내부에서 정규식으로 처리
────────────────────────────────────────────────────────────────────────────

[제공된 코드]
────────────────────────────────────────────────────────────────────────────
def detect_address(text: str) -> list:
    """간단 보조 주소 탐지: 시/도 기반, 우편번호, 도로명, 지번, 영문 주소를 포함하여 반환합니다."""
    out = []
    try:
        # ADDR_PATTERN(시/도+구/동)으로 주소 탐지
        for m in ADDR_PATTERN.finditer(text):
            addr = m.group().strip()
            out.append({"type": "LC", "value": addr, "span": m.span()})

        # 우편번호 탐지
        for m in ZIP_PATTERN.finditer(text):
            out.append({"type": "zipcode", "value": m.group().strip(), "span": m.span()})

        # 도로명/지번 탐지
        for m in STREET_PATTERN.finditer(text):
            out.append({"type": "LC", "value": m.group().strip(), "span": m.span()})

        # 영문 주소 탐지
        for m in EN_ADDR_PATTERN.finditer(text):
            out.append({"type": "LC", "value": m.group().strip(), "span": m.span()})

    except Exception as e:
        logging.error(f"[ERROR] 주소 탐지 중 오류 발생: {e}")

    return out
────────────────────────────────────────────────────────────────────────────

차이점: 제공된 코드에 별도 주소 탐지 함수 존재 (더 다양한 패턴 지원)

================================================================================
요약
================================================================================

현재 버전의 주요 개선 사항:
1. ✅ 전화번호/생년월일 오탐지 필터링 (70줄 추가)
2. ✅ 이름 탐지 다층 필터링 (40줄 추가)
3. ✅ NER 512 토큰 제한 해결 (10줄 추가)
4. ✅ 조합 위험도 준식별자 필터링 (15줄 추가)
5. ✅ 병렬 처리 (5줄 추가)

제공된 코드의 추가 기능:
1. ✅ HWP 띄어쓰기 정규화 (10줄)
2. ✅ win32com 절대 경로 처리 (os.path.abspath 추가)
3. ✅ detect_address() 함수 (30줄)
4. ✅ 우편번호 탐지 지원

권장: 현재 버전 + 제공된 코드의 HWP 정규화 + win32com 절대경로 = 최적 버전

================================================================================
